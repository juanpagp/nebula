/*
 * std/io.neb
 * ═══════════════════════════════════════════════════════════════════
 * The Public I/O API: print<T>() and println<T>()
 * 
 * This module provides type-safe, CVT-safe printing functions for any
 * type that implements the Stringable trait.
 * 
 * Design Philosophy:
 * ──────────────────
 * - Minimal: Only print and println; no format strings (yet)
 * - Safe: Uses CVT keywords to guarantee memory safety
 * - Generic: Works with any Stringable type
 * - Zero-Copy: Passes raw pointers to the C shim; no extra allocation
 * 
 * The Call Stack:
 * ───────────────
 *   print<T>(item: T)
 *       → T.toString()                       [User type impl]
 *           → (may call __nebula_itoa_*)    [std/primitives.neb]
 *       → s.getRawRef()                      [Extract pointer from string]
 *       → std::sys::__nebula_rt_write()      [Write bytes to stdout]
 * 
 * CVT Safety Analysis:
 * ────────────────────
 * Let's trace print(42):
 * 
 * 1. Call print(42: i32)
 *    - Parameter 'item' is Valid
 * 
 * 2. s = item.toString()
 *    - Allocates Region<u8> in __nebula_itoa_i32()
 *    - Region is Valid
 *    - Returns string (Region view)
 *    - s is Valid
 * 
 * 3. buf = s.getRawRef()
 *    - Extracts Ref<u8> (raw pointer)
 *    - Does NOT consume s
 *    - buf points to Valid data
 * 
 * 4. __nebula_rt_write(keeps Ref<u8> buf, i32 len)
 *    - Reads from buf
 *    - Does NOT free/destroy
 *    - buf still points to Valid data after return
 * 
 * 5. Last-Usage Analysis (end of print function)
 *    - s goes out of scope
 *    - No more uses of s (the last usage was getRawRef)
 *    - Compiler inserts s.free()
 *    - Region is deallocated
 * 
 * Result: All temporary regions created by toString() are freed,
 *         but only AFTER the syscall completes. Safe and sound!
 */

namespace std::io;

use std::Stringable;
use std::sys;

/*
 * ─────────────────────────────────────────────────────────────────
 * PUBLIC API: print<T>()
 * ─────────────────────────────────────────────────────────────────
 */

/**
 * print<T>(item: T) where T: Stringable
 * 
 * Prints the string representation of item to stdout.
 * 
 * Type Parameters:
 *   T - Any type implementing the Stringable trait
 * 
 * CVT Semantics:
 *   - The parameter 'item' is borrowed with 'keeps'
 *   - The Region allocated by toString() is Valid during the call
 *   - Last-Usage Analysis ensures the Region is freed after the syscall
 *   - No memory leaks; no dangling pointers
 * 
 * Examples:
 *   print(42);                  // prints "42"
 *   print(-17);                 // prints "-17"
 *   print(255);                 // prints "255"
 *   print("Hello, World!");      // prints "Hello, World!"
 *   
 *   i32 x = 100;
 *   print(x);                   // prints "100"; x is still Valid after
 * 
 * @param item  The value to print. Must implement Stringable.
 */
public void print<T: Stringable>(T item) {
    // Convert item to string using its Stringable implementation
    // This may allocate a Region (e.g., for integer-to-string conversion)
    string s = item.toString();
    
    // Extract the raw buffer pointer and length
    // getRawRef() returns Ref<u8> (a raw pointer)
    // length is i32 (value type, stack allocated)
    Ref<u8> buf = s.getRawRef();
    i32 len = s.length();
    
    // Call the C runtime's write syscall
    // 'keeps' indicates that __nebula_rt_write() does not consume the buffer
    std::sys::__nebula_rt_write(keeps buf, len);
    
    // At this point, Last-Usage Analysis kicks in:
    // - If 's' was allocated by toString() (temporary), it's no longer used
    // - The compiler inserts s.free() here
    // - The Region is deallocated
    // - buf still points to freed memory, but we never use it again (safe)
}

/**
 * println<T>(item: T) where T: Stringable
 * 
 * Prints the string representation of item followed by a newline.
 * 
 * Implementation:
 *   - First, calls print(item)
 *   - Then, writes a single newline character (\n, ASCII 10)
 * 
 * CVT Semantics:
 *   Same as print<T>, with an additional syscall for the newline.
 *   The newline is stored in a stack-allocated Region or static string,
 *   so there are no extra heap allocations.
 * 
 * Examples:
 *   println(42);                // prints "42\n"
 *   println("Hello, World!");    // prints "Hello, World!\n"
 *   
 *   for (i32 i = 0; i < 3; i = i + 1) {
 *       println(i);             // prints "0\n", "1\n", "2\n"
 *   }
 * 
 * @param item  The value to print. Must implement Stringable.
 */
public void println<T: Stringable>(T item) {
    // Print the item
    print(item);
    
    // Print a newline
    // We use a static string literal for the newline
    // This avoids allocating a temporary Region
    string newline = "\n";
    
    Ref<u8> buf = newline.getRawRef();
    i32 len = newline.length();
    
    std::sys::__nebula_rt_write(keeps buf, len);
    
    // newline is a literal (not allocated), so no free() is needed
}

/*
 * ─────────────────────────────────────────────────────────────────
 * FUTURE EXTENSIONS (Planned)
 * ─────────────────────────────────────────────────────────────────
 */

/*
 * Format strings (like C's printf, but type-safe):
 * 
 * void printf(keeps string format, ...args) {
 *     // Parse format string
 *     // For each %T, call the corresponding arg's toString()
 *     // Build the output string
 *     // Write it
 * }
 * 
 * Example:
 *   printf("The answer is %d and the value is %s\n", 42, "hello");
 * 
 * Challenge: Variadic generics in Nebula (not yet designed)
 */

/*
 * Input functions:
 * 
 * public string readLine() {
 *     // Allocate a Region for the line
 *     // Call std::sys::__nebula_rt_read()
 *     // Return as string
 * }
 * 
 * Challenge: Reading from stdin without knowing buffer size in advance
 */

/*
 * Formatted output with width/precision:
 * 
 * public void printInt(i32 value, i32 width) {
 *     // Pad the integer to the given width
 *     // Useful for aligning columns
 * }
 */
