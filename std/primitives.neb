/*
 * std/primitives.neb
 * ═══════════════════════════════════════════════════════════════════
 * Stringable Implementations for Primitive Types
 * 
 * This module implements toString() for i32, u8, u32, and string types.
 * 
 * Key Challenge: Integer-to-String Conversion Without stdlib
 * ────────────────────────────────────────────────────────────
 * We cannot use sprintf() or any libc function. Instead, we implement
 * a minimal itoa (integer-to-ASCII) algorithm that:
 * 
 * 1. Allocates a Region on the heap for the result
 * 2. Converts the number digit-by-digit (divide by 10)
 * 3. Handles the sign for signed integers
 * 4. Builds the string in reverse (LSB first, then reverse)
 * 
 * CVT Safety: Each Region allocation is tracked as Valid.
 *             By Last-Usage Analysis, the caller's stack frame
 *             frees temporary strings after print() completes.
 */

namespace std;

/*
 * ─────────────────────────────────────────────────────────────────
 * HELPER: Manual Integer-to-String Conversion (itoa)
 * ─────────────────────────────────────────────────────────────────
 * 
 * Since Nebula doesn't have stdlib, we implement itoa ourselves.
 * This is the core of the integer printing system.
 */

/**
 * Converts an i32 to a string representation.
 * 
 * Algorithm:
 *   - Handle negative numbers by prepending '-'
 *   - Repeatedly divide by 10, collecting remainders as digits
 *   - Build the string in reverse, then reverse it
 * 
 * Returns: A new Region containing the ASCII digits + null terminator
 * 
 * @param value  The integer to convert
 * @return       A Region<u8> containing the string representation
 * 
 * CVT Implications:
 *   - Creates a new Region (Valid state)
 *   - Caller must ensure the Region is freed via Last-Usage
 * 
 * Example:
 *   Region<u8> digits = __nebula_itoa_i32(42);
 *   // digits.length() == 2, digits.data() == "42\0"
 */
private Region<u8> __nebula_itoa_i32(i32 value) {
    // Allocate space: worst case is "-2147483648" (11 chars + null)
    Region<u8> buffer = new Region(12);
    
    i32 num = value;
    i32 isNegative = 0;
    i32 idx = 0;
    
    // Handle negative
    if (num < 0) {
        isNegative = 1;
        num = 0 - num;  // Negate (avoid unary minus initially)
    }
    
    // Convert digits
    if (num == 0) {
        buffer[0] = 48;  // ASCII '0'
        idx = 1;
    } else {
        // Extract digits in reverse
        i32 temp = num;
        while (temp > 0) {
            i32 digit = temp % 10;
            buffer[idx] = 48 + digit;  // '0' + digit
            temp = temp / 10;
            idx = idx + 1;
        }
    }
    
    // Place negative sign
    if (isNegative != 0) {
        buffer[idx] = 45;  // '-'
        idx = idx + 1;
    }
    
    // Reverse the string (in-place)
    i32 left = 0;
    i32 right = idx - 1;
    while (left < right) {
        u8 tmp = buffer[left];
        buffer[left] = buffer[right];
        buffer[right] = tmp;
        left = left + 1;
        right = right - 1;
    }
    
    // Null-terminate
    buffer[idx] = 0;
    
    // Resize Region to actual length (optional optimization)
    buffer.truncate(idx);
    
    return buffer;
}

/**
 * Converts an u32 to a string representation.
 * 
 * Similar to __nebula_itoa_i32, but without sign handling.
 */
private Region<u8> __nebula_itoa_u32(u32 value) {
    Region<u8> buffer = new Region(11);  // 10 digits + null
    
    u32 num = value;
    i32 idx = 0;
    
    if (num == 0) {
        buffer[0] = 48;  // '0'
        idx = 1;
    } else {
        u32 temp = num;
        while (temp > 0) {
            u32 digit = temp % 10;
            buffer[idx] = 48 + digit;  // Convert to ASCII
            temp = temp / 10;
            idx = idx + 1;
        }
    }
    
    // Reverse the string
    i32 left = 0;
    i32 right = idx - 1;
    while (left < right) {
        u8 tmp = buffer[left];
        buffer[left] = buffer[right];
        buffer[right] = tmp;
        left = left + 1;
        right = right - 1;
    }
    
    buffer[idx] = 0;
    buffer.truncate(idx);
    
    return buffer;
}

/**
 * Converts a u8 (unsigned byte) to a string.
 */
private Region<u8> __nebula_itoa_u8(u8 value) {
    Region<u8> buffer = new Region(4);  // max 3 digits + null
    
    u8 num = value;
    i32 idx = 0;
    
    if (num == 0) {
        buffer[0] = 48;
        idx = 1;
    } else {
        u8 temp = num;
        while (temp > 0) {
            u8 digit = temp % 10;
            buffer[idx] = 48 + digit;
            temp = temp / 10;
            idx = idx + 1;
        }
    }
    
    // Reverse
    i32 left = 0;
    i32 right = idx - 1;
    while (left < right) {
        u8 tmp = buffer[left];
        buffer[left] = buffer[right];
        buffer[right] = tmp;
        left = left + 1;
        right = right - 1;
    }
    
    buffer.set(idx, 0);
    buffer.truncate(idx);
    
    return buffer;
}

/*
 * ─────────────────────────────────────────────────────────────────
 * STRINGABLE IMPLEMENTATIONS
 * ─────────────────────────────────────────────────────────────────
 */

/**
 * impl Stringable for i32
 * 
 * Converts an i32 to its decimal string representation.
 * 
 * Example:
 *   print(42);           // Calls i32::toString() -> "42"
 *   print(-17);          // Calls i32::toString() -> "-17"
 *   print(0);            // Calls i32::toString() -> "0"
 * 
 * CVT Safety:
 *   __nebula_itoa_i32() allocates a new Region (Valid).
 *   We return a string view of that Region.
 *   The caller's Last-Usage Analysis frees the Region after print().
 */
impl Stringable for i32 {
    string toString() {
        Region<u8> digits = __nebula_itoa_i32(self);
        return Region::as_string(digits);  // Convert Region<u8> to string
    }
}

/**
 * impl Stringable for u32
 */
impl Stringable for u32 {
    string toString() {
        Region<u8> digits = __nebula_itoa_u32(self);
        return Region::as_string(digits);
    }
}

/**
 * impl Stringable for u8
 */
impl Stringable for u8 {
    string toString() {
        Region<u8> digits = __nebula_itoa_u8(self);
        return Region::as_string(digits);
    }
}

/**
 * impl Stringable for string
 * 
 * A string is already a string representation, so toString() returns itself.
 * This is the trivial Stringable implementation.
 * 
 * CVT Safety:
 *   We use 'keeps' (borrow) because we're not consuming the original string.
 *   The caller retains ownership; we just pass a view to print().
 * 
 * Example:
 *   string msg = "Hello, World!";
 *   print(msg);  // Calls string::toString() -> msg itself
 *   // msg is still Valid after print()
 */
impl Stringable for string {
    string toString() {
        return self;  // Already a string, no conversion needed
    }
}

/*
 * Future Stringable Implementations (Planned):
 * 
 * impl Stringable for bool {
 *     string toString() {
 *         if (self) return "true";
 *         else return "false";
 *     }
 * }
 * 
 * impl<T> Stringable for Vec<T> where T: Stringable {
 *     string toString() {
 *         // Format as "[item1, item2, ...]"
 *     }
 * }
 * 
 * impl<T> Stringable for Option<T> where T: Stringable {
 *     string toString() {
 *         match (self) {
 *             Some(value) => "Some(" + value.toString() + ")",
 *             None() => "None",
 *         }
 *     }
 * }
 */
