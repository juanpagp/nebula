diff --git a/src/main/java/org/nebula/cli/CliParser.java b/src/main/java/org/nebula/cli/CliParser.java
index 543a6ac..eff976b 100644
--- a/src/main/java/org/nebula/cli/CliParser.java
+++ b/src/main/java/org/nebula/cli/CliParser.java
@@ -20,11 +20,13 @@ public class CliParser
 	 * This method returns an {@link Optional} containing a {@link Result}:
 	 * <ul>
 	 * <li><b>{@code Optional.empty()}</b>:
-	 * Indicates a clean exit. --help or --version was requested and has been printed.
+	 * Indicates a clean exit. --help or --version was requested and has been
+	 * printed.
 	 * The application should exit with code 0.</li>
 	 *
 	 * <li><b>{@code Optional.of(Result.Ok(config))}</b>:
-	 * Indicates a successful parse. The {@link CompilerConfig} is valid and compilation
+	 * Indicates a successful parse. The {@link CompilerConfig} is valid and
+	 * compilation
 	 * can proceed.</li>
 	 *
 	 * <li><b>{@code Optional.of(Result.Err(error))}</b>:
@@ -82,6 +84,10 @@ public class CliParser
 					case "--ignore-warnings":
 						builder.ignoreWarnings(true);
 						break;
+					case "-b":
+					case "--bare":
+						builder.bareMetal(true);
+						break;
 
 					// --- Options with a single value ---
 					case "-e":
@@ -89,7 +95,8 @@ public class CliParser
 						i++; // Move to the next token
 						if (i >= args.length)
 						{
-							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE, "Error: Option '" + arg + "' requires an argument.")));
+							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE,
+									"Error: Option '" + arg + "' requires an argument.")));
 						}
 						builder.entryPoint(args[i]);
 						break;
@@ -110,7 +117,8 @@ public class CliParser
 						i++;
 						if (i >= args.length)
 						{
-							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE, "Error: Option '" + arg + "' requires an argument.")));
+							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE,
+									"Error: Option '" + arg + "' requires an argument.")));
 						}
 						builder.targetPlatform(args[i]);
 						break;
@@ -119,7 +127,8 @@ public class CliParser
 						i++;
 						if (i >= args.length)
 						{
-							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE, "Error: Option '" + arg + "' requires an argument.")));
+							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE,
+									"Error: Option '" + arg + "' requires an argument.")));
 						}
 						// This can throw a RuntimeException from the builder, which we catch below
 						builder.borrowCheckingLevel(args[i]);
@@ -130,7 +139,8 @@ public class CliParser
 						i++;
 						if (i >= args.length)
 						{
-							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE, "Error: Option '" + arg + "' requires an argument.")));
+							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE,
+									"Error: Option '" + arg + "' requires an argument.")));
 						}
 						builder.addLibraryPath(args[i]);
 						break;
@@ -139,7 +149,8 @@ public class CliParser
 						i++;
 						if (i >= args.length)
 						{
-							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE,"Error: Option '" + arg + "' requires an argument.")));
+							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE,
+									"Error: Option '" + arg + "' requires an argument.")));
 						}
 						builder.addLinkLibrary(args[i]);
 						break;
@@ -149,14 +160,16 @@ public class CliParser
 						i++;
 						if (i >= args.length)
 						{
-							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE, "Error: Option '" + arg + "' requires an argument.")));
+							return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_VALUE,
+									"Error: Option '" + arg + "' requires an argument.")));
 						}
 						builder.addNativeSource(args[i]);
 						break;
 
 					default:
 						// Handle unknown options
-						return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.UNKNOWN_OPTION, "Error: Unknown option '" + arg + "'")));
+						return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.UNKNOWN_OPTION,
+								"Error: Unknown option '" + arg + "'")));
 				}
 			}
 		}
@@ -166,12 +179,12 @@ public class CliParser
 			return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.INVALID_VALUE, e.getMessage())));
 		}
 
-
 		// ---- VALIDATION ----
 		// This is a post-parsing validation check
 		if (builder.getNebSources().isEmpty())
 		{
-			return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_SOURCE_FILES, "Error: Missing required <sourceFiles>.")));
+			return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.MISSING_SOURCE_FILES,
+					"Error: Missing required <sourceFiles>.")));
 		}
 
 		// All checks passed, build the final, immutable config object
@@ -183,7 +196,8 @@ public class CliParser
 		}
 		catch (Exception e)
 		{
-			return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.INVALID_VALUE, "Error creating compiler config: " + e.getMessage())));
+			return Optional.of(Result.err(new ArgParseError(ArgParseError.Type.INVALID_VALUE,
+					"Error creating compiler config: " + e.getMessage())));
 		}
 	}
 }
\ No newline at end of file
diff --git a/src/main/java/org/nebula/nebc/codegen/LLVMCodeGenerator.java b/src/main/java/org/nebula/nebc/codegen/LLVMCodeGenerator.java
index e8f4530..88855f4 100644
--- a/src/main/java/org/nebula/nebc/codegen/LLVMCodeGenerator.java
+++ b/src/main/java/org/nebula/nebc/codegen/LLVMCodeGenerator.java
@@ -1,6 +1,7 @@
 package org.nebula.nebc.codegen;
 
 import org.bytedeco.javacpp.BytePointer;
+import org.bytedeco.javacpp.PointerPointer;
 import org.bytedeco.llvm.LLVM.*;
 import org.nebula.nebc.ast.ASTNode;
 import org.nebula.nebc.ast.ASTVisitor;
@@ -53,6 +54,7 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 	 * variables.
 	 */
 	private final Map<String, LLVMValueRef> namedValues = new HashMap<>();
+	private final boolean bareMetal;
 	// ── LLVM Core Handles ───────────────────────────────────────
 	private LLVMContextRef context;
 	private LLVMModuleRef module;
@@ -63,14 +65,22 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 	 * The LLVM function currently being built (set during visitMethodDeclaration).
 	 */
 	private LLVMValueRef currentFunction;
-
 	private Type currentMethodReturnType;
-
 	/**
 	 * Whether the current basic block has already been terminated (ret/br).
 	 */
 	private boolean currentBlockTerminated;
 
+	public LLVMCodeGenerator()
+	{
+		this(false);
+	}
+
+	public LLVMCodeGenerator(boolean bareMetal)
+	{
+		this.bareMetal = bareMetal;
+	}
+
 	// =================================================================
 	// PUBLIC API
 	// =================================================================
@@ -275,9 +285,11 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 		Type returnType = analyzer.getMainMethodReturnType();
 		LLVMTypeRef i32Type = LLVMInt32TypeInContext(context);
 
-		// Build: i32 @main()
-		LLVMTypeRef mainFnType = LLVMFunctionType(i32Type, new LLVMTypeRef(), 0, 0);
-		LLVMValueRef mainFn = LLVMAddFunction(module, "main", mainFnType);
+		// Build entry point
+		String entryName = bareMetal ? "_start" : "main";
+		LLVMTypeRef entryRetType = bareMetal ? LLVMVoidTypeInContext(context) : i32Type;
+		LLVMTypeRef mainFnType = LLVMFunctionType(entryRetType, (LLVMTypeRef) null, 0, 0);
+		LLVMValueRef mainFn = LLVMAddFunction(module, entryName, mainFnType);
 
 		LLVMBasicBlockRef entry = LLVMAppendBasicBlockInContext(context, mainFn, "entry");
 		LLVMPositionBuilderAtEnd(builder, entry);
@@ -291,23 +303,57 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 
 		// Build the function type for __nebula_main: either () -> i32 or () -> void
 		LLVMTypeRef nebulaRetType = toLLVMType(returnType);
-		LLVMTypeRef nebulaMainType = LLVMFunctionType(nebulaRetType, new LLVMTypeRef(), 0, 0);
+		LLVMTypeRef nebulaMainType = LLVMFunctionType(nebulaRetType, (LLVMTypeRef) null, 0, 0);
 
 		if (returnType == PrimitiveType.VOID)
 		{
 			// void main → call, then implicit return 0
-			LLVMBuildCall2(builder, nebulaMainType, nebulaMain,
-					new LLVMValueRef(), 0, new BytePointer(""));
-			LLVMBuildRet(builder, LLVMConstInt(i32Type, 0, 0));
+			LLVMBuildCall2(builder, nebulaMainType, nebulaMain, (LLVMValueRef) null, 0, new BytePointer(""));
+			if (bareMetal)
+			{
+				emitExitSyscall(LLVMConstInt(i32Type, 0, 0));
+			}
+			else
+			{
+				LLVMBuildRet(builder, LLVMConstInt(i32Type, 0, 0));
+			}
 		}
 		else
 		{
 			// i32 main → call and return the result
-			LLVMValueRef callResult = LLVMBuildCall2(builder, nebulaMainType, nebulaMain,
-					new LLVMValueRef(), 0, new BytePointer("call"));
-			LLVMBuildRet(builder, callResult);
+			LLVMValueRef callResult = LLVMBuildCall2(builder, nebulaMainType, nebulaMain, (LLVMValueRef) null, 0,
+					new BytePointer("call"));
+			if (bareMetal)
+			{
+				emitExitSyscall(callResult);
+			}
+			else
+			{
+				LLVMBuildRet(builder, callResult);
+			}
 		}
 	}
+
+	private void emitExitSyscall(LLVMValueRef exitCode)
+	{
+		LLVMTypeRef i64Type = LLVMInt64TypeInContext(context);
+		LLVMTypeRef voidType = LLVMVoidTypeInContext(context);
+
+		// Syscall signature: void(i64)
+		LLVMTypeRef functionType = LLVMFunctionType(voidType, i64Type, 1, 0);
+
+		String asmStr = "movq $$60, %rax\nsyscall";
+		String constr = "{rdi}";
+
+		LLVMValueRef inlineAsm = LLVMGetInlineAsm(functionType, new BytePointer(asmStr), asmStr.length(),
+				new BytePointer(constr), constr.length(), 1 /* sideEffect */, 0 /* alignStack */, 0 /* AT&T */,
+				0 /* canThrow */);
+
+		LLVMValueRef status64 = LLVMBuildZExt(builder, exitCode, i64Type, "status64");
+
+		LLVMBuildCall2(builder, functionType, inlineAsm, status64, 1, new BytePointer(""));
+		LLVMBuildRetVoid(builder);
+	}
 	// =================================================================
 	// MODULE VERIFICATION
 	// =================================================================
@@ -376,11 +422,13 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 		Type returnType = funcType.getReturnType();
 		LLVMTypeRef llvmFuncType = toLLVMType(funcType);
 
-		// 3. Determine function name (handling main wrapper)
+		// 4. Add the function to the module (or retrieve if already declared)
 		String funcName = "main".equals(node.name) ? "__nebula_main" : node.name;
-
-		// 4. Add the function to the module
-		LLVMValueRef function = LLVMAddFunction(module, funcName, llvmFuncType);
+		LLVMValueRef function = LLVMGetNamedFunction(module, funcName);
+		if (function == null || function.isNull())
+		{
+			function = LLVMAddFunction(module, funcName, llvmFuncType);
+		}
 		LLVMSetLinkage(function, LLVMExternalLinkage);
 
 		// 5. Setup Entry Block
@@ -471,7 +519,8 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 					org.nebula.nebc.semantic.symbol.VariableSymbol.class);
 			if (sym == null && node.declarators.size() == 1)
 			{ // fallback
-				// Let's try to deduce from init if sym is null (which shouldn't happen)
+				// Let's try to deduce from init if sym is null (which
+				// shouldn't happen)
 				if (decl.hasInitializer())
 				{
 					// skip for now, robust symbol will be fetched below from scope if needed,
@@ -656,19 +705,25 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 			case INT ->
 			{
 				long val = ((Number) node.value).longValue();
+
 				yield LLVMConstInt(llvmType, val, /* signExtend */ 1);
 			}
 			case FLOAT ->
+
 			{
 				double val = ((Number) node.value).doubleValue();
+
 				yield LLVMConstReal(llvmType, val);
 			}
 			case BOOL ->
+
 			{
 				boolean val = (Boolean) node.value;
+
 				yield LLVMConstInt(llvmType, val ? 1 : 0, 0);
 			}
 			case CHAR ->
+
 			{
 				// char → i32 codepoint
 				int codePoint;
@@ -680,14 +735,18 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 				{
 					codePoint = ((Number) node.value).intValue();
 				}
+
 				yield LLVMConstInt(llvmType, codePoint, 0);
 			}
 			case STRING ->
+
 			{
 				// String → global constant + pointer
 				String str = node.value.toString();
+
 				yield LLVMBuildGlobalStringPtr(builder, str, ".str");
 			}
+
 		};
 	}
 
@@ -731,19 +790,24 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 			case DIV ->
 			{
 				if (isFloat)
+
 					yield LLVMBuildFDiv(builder, lVal, rVal, "fdiv");
 				yield isUnsigned ? LLVMBuildUDiv(builder, lVal, rVal, "udiv")
 						: LLVMBuildSDiv(builder, lVal, rVal, "sdiv");
 			}
 			case MOD ->
+
 			{
 				if (isFloat)
+
 					yield LLVMBuildFRem(builder, lVal, rVal, "frem");
 				yield isUnsigned ? LLVMBuildURem(builder, lVal, rVal, "urem")
 						: LLVMBuildSRem(builder, lVal, rVal, "srem");
 			}
 			case EQ ->
-					isFloat ? LLVMBuildFCmp(builder, LLVMRealOEQ, lVal, rVal, "feq")
+					isFloat ?
+
+							LLVMBuildFCmp(builder, LLVMRealOEQ, lVal, rVal, "feq")
 							: LLVMBuildICmp(builder, LLVMIntEQ, lVal, rVal, "eq");
 			case NE ->
 					isFloat ? LLVMBuildFCmp(builder, LLVMRealONE, lVal, rVal, "fne")
@@ -751,27 +815,34 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 			case LT ->
 			{
 				if (isFloat)
+
 					yield LLVMBuildFCmp(builder, LLVMRealOLT, lVal, rVal, "flt");
 				yield isUnsigned ? LLVMBuildICmp(builder, LLVMIntULT, lVal, rVal, "ult")
 						: LLVMBuildICmp(builder, LLVMIntSLT, lVal, rVal, "slt");
 			}
 			case GT ->
+
 			{
 				if (isFloat)
+
 					yield LLVMBuildFCmp(builder, LLVMRealOGT, lVal, rVal, "fgt");
 				yield isUnsigned ? LLVMBuildICmp(builder, LLVMIntUGT, lVal, rVal, "ugt")
 						: LLVMBuildICmp(builder, LLVMIntSGT, lVal, rVal, "sgt");
 			}
 			case LE ->
+
 			{
 				if (isFloat)
+
 					yield LLVMBuildFCmp(builder, LLVMRealOLE, lVal, rVal, "fle");
 				yield isUnsigned ? LLVMBuildICmp(builder, LLVMIntULE, lVal, rVal, "ule")
 						: LLVMBuildICmp(builder, LLVMIntSLE, lVal, rVal, "sle");
 			}
 			case GE ->
+
 			{
 				if (isFloat)
+
 					yield LLVMBuildFCmp(builder, LLVMRealOGE, lVal, rVal, "fge");
 				yield isUnsigned ? LLVMBuildICmp(builder, LLVMIntUGE, lVal, rVal, "uge")
 						: LLVMBuildICmp(builder, LLVMIntSGE, lVal, rVal, "sge");
@@ -793,6 +864,7 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 			default ->
 					null;
 		};
+
 	}
 
 	@Override
@@ -888,8 +960,24 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 		LLVMValueRef pointer = namedValues.get(node.name);
 		if (pointer == null)
 		{
-			// Could be a function reference or global in the future
-			throw new CodegenException("Undeclared variable referenced in codegen: " + node.name);
+			// Could be a function reference
+			org.nebula.nebc.semantic.symbol.Symbol sym = analyzer.getSymbol(node,
+					org.nebula.nebc.semantic.symbol.Symbol.class);
+			if (sym instanceof org.nebula.nebc.semantic.symbol.MethodSymbol)
+			{
+				String actualName = "main".equals(node.name) ? "__nebula_main" : node.name;
+				LLVMValueRef func = LLVMGetNamedFunction(module, actualName);
+				if (func != null)
+				{
+					return func;
+				}
+				// If not found, it might be a forward call. We should declare it.
+				org.nebula.nebc.semantic.types.FunctionType ft = ((org.nebula.nebc.semantic.symbol.MethodSymbol) sym)
+						.getType();
+				return LLVMAddFunction(module, actualName, toLLVMType(ft));
+			}
+
+			throw new CodegenException("Undeclared identifier referenced in codegen: " + node.name);
 		}
 
 		org.nebula.nebc.semantic.symbol.Symbol sym = analyzer.getSymbol(node,
@@ -904,8 +992,36 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 	@Override
 	public LLVMValueRef visitInvocationExpression(InvocationExpression node)
 	{
-		// TODO: Emit function call
-		return null;
+		LLVMValueRef function = node.target.accept(this);
+		if (function == null)
+		{
+			throw new CodegenException("Could not resolve function target for call");
+		}
+
+		Type targetType = analyzer.getType(node.target);
+		if (!(targetType instanceof FunctionType ft))
+		{
+			throw new CodegenException("Target of invocation is not a function: " + targetType.name());
+		}
+
+		LLVMTypeRef llvmFuncType = toLLVMType(ft);
+
+		int argCount = node.arguments.size();
+		LLVMValueRef[] argsArr = new LLVMValueRef[argCount];
+		for (int i = 0; i < argCount; i++)
+		{
+			Expression argNode = node.arguments.get(i);
+			LLVMValueRef argValue = argNode.accept(this);
+
+			Type paramType = ft.parameterTypes.get(i);
+			Type argSemType = analyzer.getType(argNode);
+
+			argsArr[i] = emitImplicitCast(argValue, argSemType, paramType);
+		}
+
+		PointerPointer<LLVMValueRef> args = new PointerPointer<>(argsArr);
+		String callName = ft.returnType == PrimitiveType.VOID ? "" : "call_tmp";
+		return LLVMBuildCall2(builder, llvmFuncType, function, args, argCount, callName);
 	}
 
 	@Override
@@ -1026,4 +1142,5 @@ public class LLVMCodeGenerator implements ASTVisitor<LLVMValueRef>
 		// Type references don't produce runtime values
 		return null;
 	}
+
 }
diff --git a/src/main/java/org/nebula/nebc/codegen/NativeCompiler.java b/src/main/java/org/nebula/nebc/codegen/NativeCompiler.java
index 6d9adaf..7b072de 100644
--- a/src/main/java/org/nebula/nebc/codegen/NativeCompiler.java
+++ b/src/main/java/org/nebula/nebc/codegen/NativeCompiler.java
@@ -9,6 +9,8 @@ import org.bytedeco.llvm.LLVM.LLVMTargetRef;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
 
 import static org.bytedeco.llvm.global.LLVM.*;
 
@@ -39,10 +41,11 @@ public final class NativeCompiler
 	 * @param outputPath The desired path for the output binary (e.g. "a.out").
 	 * @param triple     The LLVM target triple, or {@code null} for the host
 	 *                   default.
+	 * @param bareMetal  Whether to link for bare-metal (nostdlib, static).
 	 * @throws CodegenException if target initialisation, object emission, or
 	 *                          linking fails.
 	 */
-	public static void compile(LLVMModuleRef module, String outputPath, String triple)
+	public static void compile(LLVMModuleRef module, String outputPath, String triple, boolean bareMetal)
 	{
 		// 1. Initialise LLVM targets
 		LLVMInitializeNativeTarget();
@@ -115,22 +118,33 @@ public final class NativeCompiler
 		LLVMDisposeMessage(defaultTriple);
 
 		// 8. Link with clang
-		link(objectFile, outputPath);
+		link(objectFile, outputPath, bareMetal);
 	}
 
 	/**
 	 * Invokes {@code clang} to link the object file into a native executable.
 	 */
-	private static void link(Path objectFile, String outputPath)
+	private static void link(Path objectFile, String outputPath, boolean bareMetal)
 	{
 		try
 		{
-			ProcessBuilder pb = new ProcessBuilder(
+			List<String> command = new ArrayList<>(List.of(
 					"clang",
-					"-O3",               // add optimization
+					"-O3", // add optimization
 					objectFile.toString(),
-					"-o", outputPath,
-					"-no-pie");
+					"-o", outputPath));
+
+			if (bareMetal)
+			{
+				command.add("-nostdlib");
+				command.add("-static");
+			}
+			else
+			{
+				command.add("-no-pie");
+			}
+
+			ProcessBuilder pb = new ProcessBuilder(command);
 			pb.inheritIO();
 			Process process = pb.start();
 			int exitCode = process.waitFor();
diff --git a/src/main/java/org/nebula/nebc/core/Compiler.java b/src/main/java/org/nebula/nebc/core/Compiler.java
index b4f91ff..77ea741 100644
--- a/src/main/java/org/nebula/nebc/core/Compiler.java
+++ b/src/main/java/org/nebula/nebc/core/Compiler.java
@@ -83,7 +83,7 @@ public class Compiler
 		}
 
 		// 5. Code Generation (LLVM IR)
-		LLVMCodeGenerator codegen = new LLVMCodeGenerator();
+		LLVMCodeGenerator codegen = new LLVMCodeGenerator(config.bareMetal());
 		try
 		{
 			codegen.generate(compilationUnits, analyzer);
@@ -98,7 +98,7 @@ public class Compiler
 
 			// 6. Emit native binary
 			String outputPath = config.outputFile() != null ? config.outputFile() : "a.out";
-			NativeCompiler.compile(codegen.getModule(), outputPath, config.targetPlatform());
+			NativeCompiler.compile(codegen.getModule(), outputPath, config.targetPlatform(), config.bareMetal());
 
 			Log.info("Compiled successfully: " + outputPath);
 			return ExitCode.SUCCESS;
diff --git a/src/main/java/org/nebula/nebc/core/CompilerConfig.java b/src/main/java/org/nebula/nebc/core/CompilerConfig.java
index 30dbd03..cd97405 100644
--- a/src/main/java/org/nebula/nebc/core/CompilerConfig.java
+++ b/src/main/java/org/nebula/nebc/core/CompilerConfig.java
@@ -1,7 +1,7 @@
 package org.nebula.nebc.core;
 
-import org.nebula.cli.CliParser;
 import org.nebula.cli.ArgParseError;
+import org.nebula.cli.CliParser;
 import org.nebula.nebc.io.FileType;
 import org.nebula.nebc.io.SourceFile;
 import org.nebula.util.Result;
@@ -32,23 +32,10 @@ public record CompilerConfig(
 		boolean compileAsLibrary,
 		boolean checkOnly,
 		boolean ignoreWarnings,
-		CompilerConfig.BorrowCKLevel borrowCheckingLevel
-)
+		CompilerConfig.BorrowCKLevel borrowCheckingLevel,
+		boolean bareMetal)
 {
 
-	@Override
-	public String toString()
-	{
-		return "CompilerConfig{" +
-				"nebSources=" + nebSources +
-				", nebLibraries=" + nebLibraries +
-				", nativeSources=" + nativeSources +
-				", entryPoint='" + entryPoint + '\'' +
-				", outputFile='" + outputFile + '\'' +
-				", borrowChecking=" + borrowCheckingLevel +
-				'}';
-	}
-
 	/**
 	 * Parses CLI arguments into a fully validated {@link CompilerConfig}.
 	 * This is the single entry point for configuration.
@@ -66,6 +53,20 @@ public record CompilerConfig(
 		return parser.parse(args);
 	}
 
+	@Override
+	public String toString()
+	{
+		return "CompilerConfig{" +
+				"nebSources=" + nebSources +
+				", nebLibraries=" + nebLibraries +
+				", nativeSources=" + nativeSources +
+				", entryPoint='" + entryPoint + '\'' +
+				", outputFile='" + outputFile + '\'' +
+				", borrowChecking=" + borrowCheckingLevel +
+				", bareMetal=" + bareMetal +
+				'}';
+	}
+
 	/**
 	 * Defines the supported borrow checking levels.
 	 */
@@ -94,6 +95,7 @@ public record CompilerConfig(
 		private boolean checkOnly = false;
 		private boolean ignoreWarnings = false;
 		private BorrowCKLevel borrowCheckingLevel = BorrowCKLevel.allowed; // Default
+		private boolean bareMetal = false;
 
 		// --- Getters for validation ---
 		public List<String> getNebSources()
@@ -158,6 +160,11 @@ public record CompilerConfig(
 			this.ignoreWarnings = v;
 		}
 
+		public void bareMetal(boolean v)
+		{
+			this.bareMetal = v;
+		}
+
 		public void borrowCheckingLevel(String level)
 		{
 			try
@@ -223,8 +230,8 @@ public record CompilerConfig(
 					compileAsLibrary,
 					checkOnly,
 					ignoreWarnings,
-					borrowCheckingLevel
-			);
+					borrowCheckingLevel,
+					bareMetal);
 		}
 	}
 }
\ No newline at end of file
