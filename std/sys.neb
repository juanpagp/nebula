/*
 * std/sys.neb
 * ═══════════════════════════════════════════════════════════════════
 * The FFI Bridge: Nebula ↔ C Runtime Shim
 * 
 * This namespace provides low-level access to the C runtime layer
 * via FFI (Foreign Function Interface). All functions use the CVT keyword
 * 'keeps' to indicate that data is borrowed, not consumed.
 * 
 * The actual implementations live in runtime.c and are compiled/linked
 * before the Nebula code.
 */

namespace std::sys;

/*
 * ─────────────────────────────────────────────────────────────────
 * SYSCALL BINDINGS
 * ─────────────────────────────────────────────────────────────────
 */

/**
 * __nebula_rt_write(buf, len)
 * 
 * Writes len bytes to stdout.
 * 
 * CVT Semantics:
 *   - 'keeps': The function reads the buffer but does not free/destroy it.
 *   - Ref<u8>: A raw pointer (equivalent to C's const unsigned char*)
 *   - After the call, the Region pointed to by buf is still Valid.
 * 
 * @param buf  A pointer to the byte buffer. Must be valid and contain at least len bytes.
 * @param len  The number of bytes to write. Must be >= 0.
 * 
 * Safety:
 *   The Nebula compiler ensures via CVT that 'buf' is Valid at the call site.
 *   The C shim simply trusts the pointer and writes the bytes.
 *   No memory is freed by this function.
 */
private extern "C" {
    void __nebula_rt_write(keeps Ref<u8> buf, i32 len);
}

/*
 * Future I/O Functions (Stub Examples):
 * 
 * private extern "C" {
 *     i32 __nebula_rt_read(drops Ref<u8> buf, i32 maxLen);  // 'drops' because read may consume
 *     i32 __nebula_rt_open(keeps Ref<u8> path);             // Returns file descriptor
 *     void __nebula_rt_close(i32 fd);
 *     i64 __nebula_rt_seek(i32 fd, i64 offset);
 * }
 */
